
// Suffix tree (don’t worry about compression, just build a dumb version; know that Ukkonen’s algorithm exists and learn its guarantees)
// - Implement all of these algorithms in a language of your choice:
// Binary search (implement it both iteratively and recursively)
// Randomized quicksort (pay extra attention to the partition subroutine, as it’s useful in a lot of places)
// Mergesort
// Breadth-first search in a graph
// Depth-first search in a graph (augment it to detect cycles)
// Tree traversals (pre-order, in-order, post-order)
// Topological sort (using Tarjan’s algorithm)
// Dijkstra’s algorithm (without decrease-key)
// Longest common subsequence (using dynamic programming with matrices)
// Knapsack problem (also dynamic programming)
// - Know how to identify and solve backtracking problems. Loads of first technical phone screens on Collab-edit type environments were backtracking problems.
